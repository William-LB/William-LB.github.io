# 斐波那契数列第n项

斐波那契数列是一个很有意思的数列，它里面包含了很多问题，今天在书上看到一种新的方法来求解它的第n项，觉得很有启发性，来记录一下，顺便也比较下几种方法的差异。

## 1. 数学表达式 

首先来看斐波那契数列的数学表达式：  

$$
F(0) = 0,
$$

$$
F(1) = 1,
$$

$$
\forall n \geqslant 2, F(n) = F(n-1) + F(n-2)
$$

第0项是0，第一项是1，之后的每一项都是之前两项的和，举个例子就是：0，1，1，2，3，5，8，13，21......

## 2. 自上向下的递归

为了求解斐波那契数列的第n项，我们可以用 F(n) = F(n-1) + F(n-2) 这个性质，从F(n)开始往下递归。

```python
def Fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return Fibonacci(n-1)+Fibonacci(n-2)
```

这种方法是最直观的，但是它的效率非常低，因为在计算的过程中，做了很多次重复的计算。举个例子，n=3时，F(3) = F(2) + F(1)，这时需要计算一次F(1), 然后在计算F(2)时，F(2) = F(1) + F(0)，这时又需要计算一次F(1)。可以看出来这种方法有很大的改进空间。

## 3. 自下向上的方法

和自上向下的方法不同，自下向上的方法是从最初的两项开始，也就是说从最底层开始，每计算一项就存储一项，这样就避免了重复计算。

```python
def Fibonacci(n):
    List = [0]*(n+1)  #n+1是因为要考虑第0项
    List[1] = 1
    for i in range(2, n+1):
        List[i] = List(i-1) + List(i-2)
    return List[n]
```

这种方法从第0项和第1项开始，一点点往上加，直到加到第n项结束，时间复杂度是O(n)，看起来不错。在今天以前，我也一直觉得这是最好的办法来求解斐波那契数列了，毕竟只用了线性时间复杂度啊，但是直到今天遇见了它，我才知道，还有更好的！！！

## 4. 矩阵求解

现在就来说一说这更好的方法。先来看下面这个矩阵（为了方便看，就用下标来表示了），
$$
\begin{bmatrix}
F_{n+1} & F_n \\
F_n & F_{n-1}
\end{bmatrix}
$$
看出什么端倪了吗？没看出来很正常，看出来了就是小天才了...

再来看看下面这个矩阵乘法，
$$
\begin{bmatrix}
F_{n+1} & F_n \\
F_n & F_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}

\begin{bmatrix}
F_n & F_{n-1} \\
F_{n-1} & F_{n-2}
\end{bmatrix}
$$
有没有觉得有那么点感觉了？再来看看下面这个等式，
$$
\begin{bmatrix}
F_2 & F_1 \\
F_1 & F_0
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}
$$
是不是有內味了，现在数列的第n+1项很容易就求出来了，
$$
\begin{bmatrix}
F_{n+1} & F_n \\
F_n & F_{n-1}
\end{bmatrix}
=
{\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}}^n
$$
看到这里也许会问，这样算下来，时间复杂度也是O(n)啊，没有看出来哪里好啊。没错，到现在为止，还没有做出优化，接下来的故事才是重点。

我们记
$$
A = 
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}
$$
那么求A的n次方，我们可以使用二分的思想，
$$
A^n = 
\begin{cases}
A^{n/2} \times A^{n/2},& \text{if n is even} \\
A^{(n-1)/2} \times A^{(n-1)/2} \times A, & \text{if n is odd}
\end{cases}
$$
这样就成功地把 O(n) 的时间复杂度转化到 O(log(n)) 了，当 n 特别大时，优化效果很明显，毕竟
$$
log_2(\text{一百万}) = 19.93...
$$
好啦今天的讲解到此结束，说不定还有更好的方法来计算斐波那契数列，这还有待查找，不过可以确定的是，O(n)时间复杂度的方法从今天开始被我抛弃了哈哈哈
